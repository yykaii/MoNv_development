/**==================================================================================================================
 **【文件名称】  main.c
 **【功能测试】  用寄存器操作控制LED
 **==================================================================================================================
 **【实验平台】  STM32F103 + KEIL5.27 
 **
 **【实验操作】  USB线，插到开发板CMSIS-DAP接口上;
 **              因使用的是板载的LED，因而无需其它接线及器材;
 **              点击软件左上角的编译，编译无错后，点击LOAD，即可烧录至开发板;
 **
 **【划 重 点】  红色LED，已连接芯片的PC5引脚，至低电平可通路;
 **              蓝色LED，已连接芯片的PB2引脚，至低电平可通路;
 **              GPIO的寄存器具体解释，可参考资料文件夹中的《参考手册》-113页
 **
 **【更新记录】  2022-01-25  完善代码结构、注释
 **              2021-12-03  创建
 **
 **【备注说明】  版权归魔女科技所有，请勿商用，谢谢！ 
 **              https://demoboard.taobao.com 
====================================================================================================================*/
#include "stm32f10x.h"                       



int main(void)
{                       
    #if 1                 
    // 方式1: 野火大神视频上的写法, 稍作改善了一部分
    // 点亮：LED_RED, PC5, 低电平点亮              
    *(unsigned int*)(0x40021000|0x18) |= 0x01<<4;            // 使能GPIOC时钟，通过RCC的APB2ENR寄存器实现; 0x40021000:RCC的基址，  0x18:APB2ENR偏移地址
    *(unsigned int*)(0x40011000|0x00) &= ~(0x0F<<(4*5));     // 清零PC5上电后默认的工作模式配置;           0x40011000:GPIOC的基址，0x00-CRL偏移地址
    *(unsigned int*)(0x40011000|0x00) |= 0x01<<(4*5);        // 配置PC5新的工作模式：推挽输出;             0x40011000:GPIOC的基址，0x00-CRL偏移地址
    *(unsigned int*)(0x40011000|0x0C) &= ~(1<<5);            // 通过ODR寄存器，PC5引脚置低电平;            0x40011000:GPIOC的基址，0x0C-ODR偏移地址
    // 点亮：LED_BLUE, PB2, 低电平点亮              
    *(unsigned int*)(0x40021000|0x18) |= 0x01<<3;            // 使能GPIOB时钟，通过RCC的APB2ENR寄存器实现; 0x40021000:RCC的基址，  0x18:APB2ENR偏移地址 
    *(unsigned int*)(0x40010C00|0x00) &= ~(0x0F<<(4*2));     // 清零PB2上电后默认的工作模式配置;           0x40010C00:GPIOB的基址，0x00-CRL偏移地址 
    *(unsigned int*)(0x40010C00|0x00) |= 0x01<<(4*2);        // 配置PB2新的工作模式：推挽输出;             0x40010C00:GPIOB的基址，0x00-CRL偏移地址 
    *(unsigned int*)(0x40010C00|0x0C) &= ~(1<<2);            // 通过ODR寄存器，PB2引脚置低电平;            0x40010C00:GPIOB的基址，0x0C-ODR偏移地址 
    #endif            
                
    #if 0                
    // 方式2:原子哥寄存器的写法    
    // LED_RED, PC5,低电平点亮          
    RCC->APB2ENR |= 1<<4;                    // 使能GPIOC时钟，通过RCC的APB2ENR寄存器实现;   
    GPIOC->CRL   &= 0xFF0FFFFF;              // 清零PC5上电后默认的工作模式配置; 
    GPIOC->CRL   |= 0x00300000;              // 配置PC5新的工作模式：推挽输出;
    GPIOC->ODR   &= ~(1<<8);                 // 通过ODR寄存器，PC5引脚置低电平;
    // LED_BLUE, PB2,低电平点亮   
    RCC->APB2ENR |= 1<<3;                    // 使能GPIOB时钟，通过RCC的APB2ENR寄存器实现   
    GPIOB->CRL   &= 0xFFFFF0FF;              // 清零PB2上电后默认的工作模式配置; 
    GPIOB->CRL   |= 0x00000300;              // 配置PB2新的工作模式：推挽输出;  
    GPIOB->ODR   &= ~(1<<2);                 // 通过ODR寄存器，PB2引脚置低电平;   
    #endif        
        
    #if 0        
    // 方式3: 工作中常用的寄存器操作风格；注意，这些英文“名称”，是stm32f10x.h文件中的宏定义
    // 点亮：LED_RED, PC5，置低电平可通路 
    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN ;     // 使能GPIOC端口
    GPIOC->CRL   &= 0xFF0FFFFF;              // 清零PC5上电后默认的工作模式; 
    GPIOC->CRL   |= 0x00300000;              // 配置PC5工作模式：推挽输出;
    GPIOC->BRR    = 1<<5;                    // PC5置低电平; 改变引脚电平，BRR和BSRR寄存器比ODR寄存器更高效．
    // 点亮：LED_BLUE, PB2，置低电平可通路            
    RCC->APB2ENR |= RCC_APB2ENR_IOPBEN ;     // 使能GPIOB端口
    GPIOB->CRL   &= 0xFFFFF0FF;              // 清零PB2上电后默认的工作模式;
    GPIOB->CRL   |= 0x00000300;              // 配置PB2工作模式：推挽输出;
    GPIOB->BRR    = 1<<2;                    // PB2置低电平; 改变引脚电平，BRR和BSRR寄存器比ODR寄存器更高效．
    #endif
        
    while(1)                                 // while函数死循环；作用：不能让main函数运行结束，否则会产生硬件错误
    {      
                                             // 函数内空着也行
    }          
}


// 每个代码文件的末尾，注意要加两个空行

