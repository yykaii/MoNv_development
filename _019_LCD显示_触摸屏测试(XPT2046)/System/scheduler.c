/***********************************************************************************************************************************
 ** 【文件名称】  system_f103.c
 ** 【编写人员】  魔女开发板团队
 ** 【更新分享】  Q群文件夹        
 ** 【淘    宝】  魔女开发板      https://demoboard.taobao.com
 ***********************************************************************************************************************************
 ** 【使用说明】  1- 平台无关
 **               2- 全局函数：
 **                  vScheduler_TickCnt()   任务轮询值处理；本函数插在SysTick中断服务函数中，作用：任务轮询判断值;
 **                  vScheduler_Run()       任务轮询; while中不断调用本函数，以执行任务;
 **               3- 移植方法：
 **                  在SysTick中断服务函数的文件中：#include "scheduler.h"，以使其可调用本文件函数
 **                  vScheduler_TickCnt()放到SysTick中断服务函数中，如果Systick不是1ms中断一次，则要作代码修改;
 **                  vScheduler_Run()放到main的while循环中；
 **                  要间隔执行的代码，按需放到各vTask_xxms()函数中；
 **                  注意：每个vTask_xxms()任务函数的总运行时长，不要超过本函数的轮询时长；可使用System_TestRunTimes()测试运行时长
 **
 ** 【更新记录】  2020-04-21  创建
 **               2021-02-25  完善注释
 **
==================================================================================================================================*/
#include "scheduler.h"
#include "hardware.h"




/*****************************************************************************
 ** 本地变量、函数声明定义
 *****************************************************************************/
static u16 usTick_1ms     = 0;
static u16 usTick_2ms     = 0;
static u16 usTick_5ms     = 0;
static u16 usTick_10ms    = 0;
static u16 usTick_50ms    = 0;
static u16 usTick_100ms   = 0;
static u16 usTick_500ms   = 0;
static u16 usTick_1000ms = 0;

void vTask_1ms(void);
void vTask_2ms(void);
void vTask_5ms(void);
void vTask_10ms(void);
void vTask_50ms(void);
void vTask_100ms(void);
void vTask_500ms(void);
void vTask_1000ms(void);



/*============================================================================
 * 函  数：vScheduler_TickCnt
 * 功  能：任务轮询值处理; 本函数插在SysTick中断服务函数中，作用：任务轮询判断值
 * 参  数：
 * 返回值：
 * 备  注： 魔女开发板团队 2020年04月21日
============================================================================*/
void Scheduler_TickCnt(void)
{
    ++usTick_1ms;
    ++usTick_2ms;
    ++usTick_5ms;
    ++usTick_10ms;
    ++usTick_50ms;
    ++usTick_100ms;
    ++usTick_500ms;
    ++usTick_1000ms;
}



/**============================================================================
 ** 函  数：vScheduler_Run
 ** 功  能：任务轮询; while中不断调用本函数，以执行任务
 ** 参  数：
 ** 返回值：
 ** 备  注：魔女开发板团队 2020年04月21日
=============================================================================*/
void Scheduler_Run(void)
{
    if (usTick_1ms   >= 1)
    {
        usTick_1ms = 0;         // 每1ms   执行1次的任务
        vTask_1ms();
    }
    if (usTick_2ms   >= 2)
    {
        usTick_2ms = 0;         // 每2ms   执行1次的任务
        vTask_2ms();
    }
    if (usTick_5ms   >= 5)
    {
        usTick_5ms = 0;         // 每5ms   执行1次的任务
        vTask_5ms();
    }
    if (usTick_10ms  >= 10)
    {
        usTick_10ms = 0;        // 每10ms  执行1次的任务
        vTask_10ms();
    }
    if (usTick_50ms  >= 50)
    {
        usTick_50ms = 0;        // 每50ms  执行1次的任务
        vTask_50ms();
    }
    if (usTick_100ms >= 100)
    {
        usTick_100ms = 0;       // 每100ms 执行1次的任务
        vTask_100ms();
    }
    if (usTick_500ms >= 500)
    {
        usTick_500ms = 0;       // 每500ms 执行1次的任务
        vTask_500ms();
    }
    if (usTick_1000ms >= 1000)
    {
        usTick_1000ms = 0;      // 每1000ms执行1次 的任务
        vTask_1000ms();
    }
}



/*****************************************************************************
 ** 1ms
 ** 每间隔1ms，被vScheduler_Run()调用一次
 ****************************************************************************/
void vTask_1ms(void)
{
    // 每1ms执行一次的代码

    XPT2046_TouchHandler();           // 触摸屏状态检测：1:检测是否有按下，2:如果有按下，就处理好按下的坐标

}



/*****************************************************************************
 ** 2ms
 ** 每间隔2ms，被vScheduler_Run()调用一次
 ****************************************************************************/
void vTask_2ms(void)
{



}



/*****************************************************************************
 ** 5ms
 ** 每间隔5ms，被vScheduler_Run()调用一次
 ****************************************************************************/
void vTask_5ms(void)
{


}



/*****************************************************************************
 ** 10ms
 ** 每间隔10ms，被vScheduler_Run()调用一次
 ****************************************************************************/
void vTask_10ms(void)
{



}

/*****************************************************************************
 ** 50ms
 ** 每间隔50ms，被vScheduler_Run()调用一次
 ****************************************************************************/
void vTask_50ms(void)
{



}



/*****************************************************************************
 ** 100ms
 ** 每间隔100ms，被vScheduler_Run()调用一次
 ****************************************************************************/
void vTask_100ms(void)
{
    static char strTemp[100];

    if (xUSART.USART1ReceivedNum > 0) // 如果USART1收到数据(从串口上位机中发过来的）
    {
        // 1：打印到串口上位机
        sprintf(strTemp, "\rUSART1收到%d字节数据", xUSART.USART1ReceivedNum);
        USART1_SendString(strTemp);
        sprintf(strTemp, "\r收到的数据<<<：%s\r\n", (char *)xUSART.USART1ReceivedBuffer);
        USART1_SendString(strTemp);

        // 2: 重新校准
        if (strcmp((char *)xUSART.USART1ReceivedBuffer, "XPT2046") == 0)
        {
            XPT2046_ReCalibration();
        }
        xUSART.USART1ReceivedNum = 0;
    }
}



/*****************************************************************************
 ** 500ms
 ** 每间隔500ms，被vScheduler_Run()调用一次
 ****************************************************************************/
void vTask_500ms(void)
{
    LED_RED_TOGGLE;             // 红色LED 每1秒闪灭一次，以监察系统正常工作

}



/*****************************************************************************
 ** 1000ms
 ** 每间隔1000ms，被vScheduler_Run()调用一次
 ****************************************************************************/
void vTask_1000ms(void)
{


}


