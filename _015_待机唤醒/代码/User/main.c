/*==================================================================================================================
 **【文件名称】  main.c
 **【功    能】  待机唤醒
 ===================================================================================================================
 **【实验平台】  STM32F103 + KEIL5.27 
 **
 **【划 重 点】 1_PA0引脚用于待机唤醒
 **             2_PA0无需初始化，进入待机状态时，芯片检测到PA0的上升沿跳变，即可产生唤醒     
 **             
 **
 **【备注说明】 版权归魔女科技所有，请勿商用，谢谢！ 
 **             https://demoboard.taobao.com 
===================================================================================================================*/
#include <stm32f10x.h>            // 头文件引用(标准库); 内核、芯片外设....;(stm32f10x.conf.h, 对标准库头文件进行调用)     
#include "stm32f10x_conf.h"       // 头文件引用(标准库); 内核、芯片外设....;(stm32f10x.conf.h, 对标准库头文件进行调用) 
#include "system_f103.h"
#include "bsp_led.h"              // LED指示灯
#include "bsp_usart.h"            // 串口支持文件



static void delay_ms(uint32_t ms)      // 定义一个ms延时函数，减少移植时对外部文件依赖;
{
    ms=ms*6500;                  
    for(uint32_t i=0; i<ms; i++);      // 72MHz系统时钟下，大约6500个空循环耗时1ms
}



int main(void)                                        // 主函数, 整个工程的用户代码起始点
{   
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);   // 中断分组，组2:抢占级0~3,子优先级0~3 ; 全局只设置一次，尽量放在显眼的地方
    USART1_Init(115200);                              // 串口1初始化; 用于与串口软件通信，方便代码调试; USART1(115200-N-8-1), 且工程已把printf重定向至USART1输出
      
    Led_Init();                                       // LED 初始化
    LED_BLUE_ON ;                                     // 点亮蓝灯
    LED_RED_ON;                                       // 点亮红灯
    delay_ms(500);                                    // 间隔延时
        

        
    RCC->APB1ENR|=1<<28;                              // 使能电源管理PWR时钟  
    if((PWR->CSR & 0x01))                             // 判断唤醒标志：0_正常上电复位; 1_唤醒或RTC闹钟事件
        printf("\r本次复位为：唤醒复位\r");
    else
        printf("\r本次复位为：上电复位\r");    

    printf("\r 实验说明：\r");
    printf("\r 进入待机模式后，按下KEY_1,即可使PA0置高电平，以唤醒系统;");
    printf("\r 待机模式下，唤醒后系统会进行复位，程序重新开始执行;\r");
    printf("\r 可通过检测唤醒标志位确定复位来源，以进行代码处理;\r");   
    
    while(1)                                          // while函数死循环，不能让main函数运行结束，否则会产生硬件错误
    { 
        delay_ms(1000);                              // 间隔延时
        LED_RED_TOGGLE;                               // 规律地闪烁红色LED，以方便观察系统是否正常运行   
        printf("准备进入待机模式: 3\r");     
            
        delay_ms(1000);                  
        LED_RED_TOGGLE;                 
        printf("准备进入待机模式: 2\r");
            
        delay_ms(1000);                  
        LED_RED_TOGGLE;                 
        printf("准备进入待机模式: 1\r");
            
        delay_ms(1000);
        printf("准备进入待机模式: 0\r");
            
        System_Standby();                        // 进入待机模式，按下按键1
    }          
}




